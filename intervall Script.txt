from mpmath import iv
from functools import wraps

from jax import lax
from jax.extend import core
from jax._src.util import safe_map

import jax.numpy as jnp

import jax
# from jax import jit
# import numpy as np

# Configurations mpmath
iv.dps = 15
iv.pretty = True

def f(x):
    
    return jnp.exp(jnp.tanh(x))

def interval_exp(x, **kwargs):
    return iv.exp(x)

def interval_tanh(x, **kwargs):
    x = 1 - (2/(iv.exp(2*x)+1))
    return x


def interval_add(x, **kwargs):
    return iv.fsum(x[0], x[1])

def interval_mult(x, **kwargs):
    
    return iv.mul_accurately(x[0], x[1])





interval_primitives = {
    lax.exp_p: interval_exp,
    lax.tanh_p: interval_tanh,
    lax.add_p: interval_add,
    lax.mul_p: interval_mult
}

# closed_jaxpr = jax.make_jaxpr(f)(jnp.ones(5))
# print(closed_jaxpr.jaxpr)
# print(closed_jaxpr.literals)


# this is a simple Jaxpr interpreter that evaluates a Jaxpr by interpreting it directly.
def eval_jaxpr(jaxpr, consts, *args):

    env = {}
    
    # retrieving either literals or computed results
    def read(var):
        # Literals are values baked into jaxpr
        if type(var) is core.Literal: # check if var is a literal, a literal is constant value
            print("Literal:", var, type(var))
            return iv.mpf(var.val)
        return env[var]
    
    #stores computed results in environment
    def write(var, val): # write to the environment
        env[var] = val
    
    # binding args and consts to environment
    safe_map(write, jaxpr.invars, args) # safe_map applies write func to each element in jaxpr.invars & args, jaxpr.invars are input variables, and args. The difference is that args are the values of the input variables, while jaxpr.invars are the variables that hold the input variables.
    safe_map(write, jaxpr.constvars, consts) # safe_map applies write func to each jaxpr.constvars & consts, jaxpr.constvars are constant variables, and consts are the constants. The difference is that consts are the values of the constants, while jaxpr.constvars are the variables that hold the constants.
    
    # Loop through equations and eval primitives using `bind`
    for eqn in jaxpr.eqns: # looping through the equations in the jaxpr

        invars = safe_map(read, eqn.invars) # apply read for eachinput var in eqn.invars
        #`bind` is how a primitive is called
        if eqn.primitive in interval_primitives:
            outvals = [interval_primitives[eqn.primitive](*invars, **eqn.params)]
        else:
            print("Primitive not in interval_primitives:", eqn.primitive)
        
        outvals = eqn.primitive.bind(*invars, **eqn.params) # this is where the primitive is called, the primitive is a function that takes in the input variables and parameters and returns the output variables
        #Primitives may return multiple outputs or not
        if not eqn.primitive.multiple_results: # check if the primitive returns multiple results
            #if not, wrap the result in a list to make it easier to handle, if it does, we will just use the result as is
            outvals = [outvals]
        
        #write results of primitive into env.
        safe_map(write, eqn.outvars, outvals)
    
    # read final result of Jaxpr from env.
    return safe_map(read, jaxpr.outvars) # read the output variables from the environment and return them as a list

#func call
closed_jaxpr = jax.make_jaxpr(f)(jnp.ones(5))
# print("closed_jaxpr:")
# print(closed_jaxpr)
# print("closed_jaxpr.jaxpr:")
# print(closed_jaxpr.jaxpr)
# print("closed_jaxpr.literals:")
# print(closed_jaxpr.literals)
evalJaxpr = eval_jaxpr(closed_jaxpr.jaxpr, closed_jaxpr.literals, jnp.ones(5))


print("evalJaxpr:")
print(evalJaxpr)
print("evalJaxpr[0]:")
print(evalJaxpr[0])

# print(eval_jaxpr(closed_jaxpr.jaxpr, closed_jaxpr.literals, jnp.ones(5)))

inverse_registry = {}

inverse_registry[lax.exp_p] = jnp.log
inverse_registry[lax.tanh_p] = jnp.arctanh



def inverse(fun):
    @wraps(fun)
    def wrapped(*args, **kwargs):
        #since we assume unary functions (functions with one arg only), we wont worry about flattening and unflattening args
        closed_jaxpr = jax.make_jaxpr(fun)(*args, **kwargs)
        out = inverse_jaxpr(closed_jaxpr.jaxpr, closed_jaxpr.literals, *args)
        return out[0]
    return wrapped


def inverse_jaxpr(jaxpr, consts, *args):
    env = {}
    
    def read(var):
        if type(var) is core.Literal:
            return var.val
        return env[var]
    
    def write(var, val):
        env[var] = val
    #args now correspond to Jaxpr outvars
    safe_map(write, jaxpr.outvars, args)
    safe_map(write, jaxpr.constvars, consts)
    
    # loop backwards
    for eqn in jaxpr.eqns[::-1]:
        #outvars are now invars
        invals = safe_map(read, eqn.outvars)
        if eqn.primitive not in inverse_registry:
            raise NotImplementedError(f"{eqn.primitive} does not have registered inverse.")
        #assuming a unary function
        outval = inverse_registry[eqn.primitive](*invals)
        safe_map(write, eqn.invars, [outval])
    return safe_map(read, jaxpr.invars)



# f_inv = inverse(f)
# assert jnp.allclose(f_inv(f(1.0)), 1.0)
# assert jnp.allclose(f_inv(f(1.0)), 1.0, rtol=1e-5, atol=1e-6)

# print(f_inv(f(1.0)))
# print("Diff:", f_inv(f(1.0)) - 1.0)


# print(jax.make_jaxpr(inverse(f))(f(1.)))